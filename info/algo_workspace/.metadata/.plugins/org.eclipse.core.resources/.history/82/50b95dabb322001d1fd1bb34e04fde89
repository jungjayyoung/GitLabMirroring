package boj;

import java.io.*;
import java.util.*;

public class p16235 {
	
	static int n,m,k;
	static int[][] A;
	static List<Integer>[][] tree;
	static List<Integer>[][] dead_tree;
	static int[][] land; //현재 땅의 양분

	public static void main(String[] args) throws IOException{
		BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
		StringTokenizer st;
		
		st = new StringTokenizer(br.readLine()," ");
		int n = Integer.parseInt(st.nextToken());
		int m = Integer.parseInt(st.nextToken());
		int k = Integer.parseInt(st.nextToken());
		
		
		A = new int[n+1][n+1];
		land = new int[n+1][n+1];
		
		tree = new List[n+1][n+1];
		dead_tree = new List[n+1][n+1];
		
		// x,y 좌표에 나무를 집어넣을 리스트를 만들어 준다.
		for(int i=0;i<n+1;i++) {
			for(int j=0;j<n+1;j++) {
				tree[i][j] = new ArrayList<Integer>();
			}
		}
		
		// 죽은 나무의 양분을 저장할 곳
		for(int i=0;i<n+1;i++) {
			for(int j=0;j<n+1;j++) {
				dead_tree[i][j] = new ArrayList<Integer>();
			}
		}
		
		// 겨울에 추가할 양분의 양 A[][] 배열을 입력받는다.
		for(int y = 1; y <= n; y++) {
			
			st = new StringTokenizer(br.readLine()," ");
			for(int x = 1; x <= n; x++) {
				
				A[y][x] = Integer.parseInt(st.nextToken());
			}
		}
		
		// x,y 좌표에 나무를 집어넣는다.
		for(int i =0; i < m; i++) {
			st = new StringTokenizer(br.readLine()," ");
			int a,b,c;
			a = Integer.parseInt(st.nextToken()); // y
			b = Integer.parseInt(st.nextToken()); // x
			c = Integer.parseInt(st.nextToken()); // 나이
			tree[a][b].add(c);
			
		}
		
		// 각 좌표의 나무들을 나이 순으로 오름차순 정렬해준다.
		for(int y = 1; y <= n; y++) {
			for(int x =1; x <= n; x++) {
				if(!tree[y][x].isEmpty()) {
					Collections.sort(tree[y][x]);
				}
			}
		}
		
		// 현재 땅의 양분
		for(int y = 1; y <= n; y++) {
			for(int x =1; x <= n; x++) {
				land[y][x] = 5;
			}
		}
		
		
		while(k > 0) {
			
			// 봄
			// 나이가 어린 나무부터 양분을 먹고 양분이 부족하면 그 나무는 죽는다.
			for(int y = 1; y <= n; y++) {
				
				for(int x = 1; x <= n; x++) {
					
					// 현재 땅에 나무가 존재
					if(!tree[y][x].isEmpty()) {
						
						for(int i = 0; i< tree[y][x].size();i++) {
							
							// 현재 나무의 나이보다 양분이 부족하다면
							if(land[y][x] < tree[y][x].get(i)){
								
								// 뒤에 있는 나무들도 나이순이므로 죽게 된다.
								while(tree[y][x].size() > i) {
									dead_tree[y][x].add(tree[y][x].get(i) / 2);
									tree[y][x].remove(i);
								}
								
								break;
								
							}else { // 양분이 존재 한다면
								// 나이 만큼 양분이 감소
								land[y][x] -= tree[y][x].get(i);
								// 나이가 1 증가
								tree[y][x].set(i, tree[y][x].get(i) + 1);
							}
							
							
						}
						
					}
					
				}
			}
			
			// 여름
			for(int y = 1; y <= n; y++) {
				
				for(int x =1; x <= n; x++) {
					
					if(!dead_tree[y][x].isEmpty()) {
						
						// 죽은 나무 양분 추가하고 리스트 초기화
						for(int i =0; i < dead_tree[y][x].size();i++) {
							land[y][x] += dead_tree[y][x].get(i);
						}
						dead_tree[y][x].clear();
					}
					
				}
			}
			
			// 가을
			for(int y = 1; y <=n;y++) {
				
				for(int x = 1; x <= n; x++) {
					
					if(!tree[y][x].isEmpty()) {
						
						for(int i = 0; i < tree[y][x].size();i++) {
							
							// 5의 배수이면 번식한다.
							if(tree[y][x].get(i) % 5 == 0) {
								
								if(x-1 > 1) {
									tree[y][x-1].add(1);
									
									if(y - 1 > 1) {
										tree[y-1][x-1].add(1);
									}
									
									if(y + 1 <= n) {
										tree[y+1][x-1].add(1);
									}
									
								}
								
								if(y - 1 > 1) {
									tree[y-1][x].add(1);
								}
								
								if(y + 1 <= n) {
									tree[y+1][x].add(1);
								}
								
								if(x + 1 <= n) {
									
									if(y - 1 > 1) {
										tree[y-1][x+1].add(1);
									}
									
									tree[y][x + 1].add(1);
									
									if(y + 1 <= n) {
										tree[y+1][x+1].add(1);
									}
								}
							}
							//  좌표 한 곳 번식 끝 
						}
						
					}
					
				}
			}
			// 전체 좌표 번식 끝
			
			
			// 나무들 다시 sorting
			for(int y = 1; y <=n; y++) {
				for(int x = 1; x<=n; x++) {
					if(!tree[y][x].isEmpty()) {
						Collections.sort(tree[y][x]);
					}
				}
			}
			
			
			
			// 겨울
			// S2D2가 양분 추가
			for(int y = 1; y <= n; y++) {
				for(int x = 1; x <= n; x++) {
					land[y][x] += A[y][x];
				}
			}
			
			for(int y = 1; y <= n; y++) {
				for(int x = 1; x <= n; x++) {
					System.out.print(land[y][x] + " ");
				}
				System.out.println();
			}
			System.out.println();
			
			k--;
		}
		int cnt = 0;
		for(int y = 1; y <= n; y++) {
			for(int x = 1; x <= n; x++) {
				if(!tree[y][x].isEmpty())
					cnt += tree[y][x].size();
			}
		}
		System.out.println(cnt);
		
	}

}
